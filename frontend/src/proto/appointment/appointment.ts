/* eslint-disable no-case-declarations */
/* eslint-disable prefer-const */
// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "appointment/appointment.proto" (package "appointment", syntax proto3)
// tslint:disable
import { Empty } from "../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * Appointment message definition
 *
 * @generated from protobuf message appointment.Appointment
 */
export interface Appointment {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: string title = 2
   */
  title: string;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp start_time = 3
   */
  startTime?: Timestamp;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp end_time = 4
   */
  endTime?: Timestamp;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
   */
  createdAt?: Timestamp;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp updated_at = 6
   */
  updatedAt?: Timestamp;
}
/**
 * Request messages
 *
 * @generated from protobuf message appointment.CreateAppointmentRequest
 */
export interface CreateAppointmentRequest {
  /**
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp start_time = 2
   */
  startTime?: Timestamp;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp end_time = 3
   */
  endTime?: Timestamp;
}
/**
 * @generated from protobuf message appointment.GetAppointmentRequest
 */
export interface GetAppointmentRequest {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
}
/**
 * @generated from protobuf message appointment.DeleteAppointmentRequest
 */
export interface DeleteAppointmentRequest {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
}
/**
 * @generated from protobuf message appointment.ListAppointmentsRequest
 */
export interface ListAppointmentsRequest {
  /**
   * @generated from protobuf field: int32 page = 1
   */
  page: number;
  /**
   * @generated from protobuf field: int32 limit = 2
   */
  limit: number;
  /**
   * @generated from protobuf field: string search = 3
   */
  search: string;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp start_date = 4
   */
  startDate?: Timestamp;
  /**
   * @generated from protobuf field: google.protobuf.Timestamp end_date = 5
   */
  endDate?: Timestamp;
}
/**
 * @generated from protobuf message appointment.ListAppointmentsResponse
 */
export interface ListAppointmentsResponse {
  /**
   * @generated from protobuf field: repeated appointment.Appointment appointments = 1
   */
  appointments: Appointment[];
  /**
   * @generated from protobuf field: int32 total = 2
   */
  total: number;
  /**
   * @generated from protobuf field: int32 page = 3
   */
  page: number;
  /**
   * @generated from protobuf field: int32 limit = 4
   */
  limit: number;
}
/**
 * @generated from protobuf message appointment.AppointmentStreamResponse
 */
export interface AppointmentStreamResponse {
  /**
   * @generated from protobuf field: appointment.AppointmentStreamResponse.EventType event_type = 1
   */
  eventType: AppointmentStreamResponse_EventType;
  /**
   * @generated from protobuf field: appointment.Appointment appointment = 2
   */
  appointment?: Appointment;
}
/**
 * @generated from protobuf enum appointment.AppointmentStreamResponse.EventType
 */
export enum AppointmentStreamResponse_EventType {
  /**
   * @generated from protobuf enum value: CREATED = 0;
   */
  CREATED = 0,
  /**
   * @generated from protobuf enum value: UPDATED = 1;
   */
  UPDATED = 1,
  /**
   * @generated from protobuf enum value: DELETED = 2;
   */
  DELETED = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class Appointment$Type extends MessageType<Appointment> {
  constructor() {
    super("appointment.Appointment", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "start_time", kind: "message", T: () => Timestamp },
      { no: 4, name: "end_time", kind: "message", T: () => Timestamp },
      { no: 5, name: "created_at", kind: "message", T: () => Timestamp },
      { no: 6, name: "updated_at", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<Appointment>): Appointment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.title = "";
    if (value !== undefined)
      reflectionMergePartial<Appointment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Appointment
  ): Appointment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string title */ 2:
          message.title = reader.string();
          break;
        case /* google.protobuf.Timestamp start_time */ 3:
          message.startTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startTime
          );
          break;
        case /* google.protobuf.Timestamp end_time */ 4:
          message.endTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.endTime
          );
          break;
        case /* google.protobuf.Timestamp created_at */ 5:
          message.createdAt = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.createdAt
          );
          break;
        case /* google.protobuf.Timestamp updated_at */ 6:
          message.updatedAt = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updatedAt
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Appointment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string title = 2; */
    if (message.title !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.title);
    /* google.protobuf.Timestamp start_time = 3; */
    if (message.startTime)
      Timestamp.internalBinaryWrite(
        message.startTime,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* google.protobuf.Timestamp end_time = 4; */
    if (message.endTime)
      Timestamp.internalBinaryWrite(
        message.endTime,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* google.protobuf.Timestamp created_at = 5; */
    if (message.createdAt)
      Timestamp.internalBinaryWrite(
        message.createdAt,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* google.protobuf.Timestamp updated_at = 6; */
    if (message.updatedAt)
      Timestamp.internalBinaryWrite(
        message.updatedAt,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.Appointment
 */
export const Appointment = new Appointment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAppointmentRequest$Type extends MessageType<CreateAppointmentRequest> {
  constructor() {
    super("appointment.CreateAppointmentRequest", [
      { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "start_time", kind: "message", T: () => Timestamp },
      { no: 3, name: "end_time", kind: "message", T: () => Timestamp },
    ]);
  }
  create(
    value?: PartialMessage<CreateAppointmentRequest>
  ): CreateAppointmentRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.title = "";
    if (value !== undefined)
      reflectionMergePartial<CreateAppointmentRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateAppointmentRequest
  ): CreateAppointmentRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string();
          break;
        case /* google.protobuf.Timestamp start_time */ 2:
          message.startTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startTime
          );
          break;
        case /* google.protobuf.Timestamp end_time */ 3:
          message.endTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.endTime
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateAppointmentRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    /* google.protobuf.Timestamp start_time = 2; */
    if (message.startTime)
      Timestamp.internalBinaryWrite(
        message.startTime,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* google.protobuf.Timestamp end_time = 3; */
    if (message.endTime)
      Timestamp.internalBinaryWrite(
        message.endTime,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.CreateAppointmentRequest
 */
export const CreateAppointmentRequest = new CreateAppointmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppointmentRequest$Type extends MessageType<GetAppointmentRequest> {
  constructor() {
    super("appointment.GetAppointmentRequest", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<GetAppointmentRequest>): GetAppointmentRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    if (value !== undefined)
      reflectionMergePartial<GetAppointmentRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetAppointmentRequest
  ): GetAppointmentRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetAppointmentRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.GetAppointmentRequest
 */
export const GetAppointmentRequest = new GetAppointmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAppointmentRequest$Type extends MessageType<DeleteAppointmentRequest> {
  constructor() {
    super("appointment.DeleteAppointmentRequest", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DeleteAppointmentRequest>
  ): DeleteAppointmentRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    if (value !== undefined)
      reflectionMergePartial<DeleteAppointmentRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteAppointmentRequest
  ): DeleteAppointmentRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteAppointmentRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.DeleteAppointmentRequest
 */
export const DeleteAppointmentRequest = new DeleteAppointmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAppointmentsRequest$Type extends MessageType<ListAppointmentsRequest> {
  constructor() {
    super("appointment.ListAppointmentsRequest", [
      { no: 1, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "search", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "start_date", kind: "message", T: () => Timestamp },
      { no: 5, name: "end_date", kind: "message", T: () => Timestamp },
    ]);
  }
  create(
    value?: PartialMessage<ListAppointmentsRequest>
  ): ListAppointmentsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.page = 0;
    message.limit = 0;
    message.search = "";
    if (value !== undefined)
      reflectionMergePartial<ListAppointmentsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListAppointmentsRequest
  ): ListAppointmentsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 page */ 1:
          message.page = reader.int32();
          break;
        case /* int32 limit */ 2:
          message.limit = reader.int32();
          break;
        case /* string search */ 3:
          message.search = reader.string();
          break;
        case /* google.protobuf.Timestamp start_date */ 4:
          message.startDate = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startDate
          );
          break;
        case /* google.protobuf.Timestamp end_date */ 5:
          message.endDate = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.endDate
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListAppointmentsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 page = 1; */
    if (message.page !== 0) writer.tag(1, WireType.Varint).int32(message.page);
    /* int32 limit = 2; */
    if (message.limit !== 0)
      writer.tag(2, WireType.Varint).int32(message.limit);
    /* string search = 3; */
    if (message.search !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.search);
    /* google.protobuf.Timestamp start_date = 4; */
    if (message.startDate)
      Timestamp.internalBinaryWrite(
        message.startDate,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* google.protobuf.Timestamp end_date = 5; */
    if (message.endDate)
      Timestamp.internalBinaryWrite(
        message.endDate,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.ListAppointmentsRequest
 */
export const ListAppointmentsRequest = new ListAppointmentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAppointmentsResponse$Type extends MessageType<ListAppointmentsResponse> {
  constructor() {
    super("appointment.ListAppointmentsResponse", [
      {
        no: 1,
        name: "appointments",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => Appointment,
      },
      { no: 2, name: "total", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<ListAppointmentsResponse>
  ): ListAppointmentsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appointments = [];
    message.total = 0;
    message.page = 0;
    message.limit = 0;
    if (value !== undefined)
      reflectionMergePartial<ListAppointmentsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListAppointmentsResponse
  ): ListAppointmentsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated appointment.Appointment appointments */ 1:
          message.appointments.push(
            Appointment.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* int32 total */ 2:
          message.total = reader.int32();
          break;
        case /* int32 page */ 3:
          message.page = reader.int32();
          break;
        case /* int32 limit */ 4:
          message.limit = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListAppointmentsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated appointment.Appointment appointments = 1; */
    for (let i = 0; i < message.appointments.length; i++)
      Appointment.internalBinaryWrite(
        message.appointments[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* int32 total = 2; */
    if (message.total !== 0)
      writer.tag(2, WireType.Varint).int32(message.total);
    /* int32 page = 3; */
    if (message.page !== 0) writer.tag(3, WireType.Varint).int32(message.page);
    /* int32 limit = 4; */
    if (message.limit !== 0)
      writer.tag(4, WireType.Varint).int32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.ListAppointmentsResponse
 */
export const ListAppointmentsResponse = new ListAppointmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppointmentStreamResponse$Type extends MessageType<AppointmentStreamResponse> {
  constructor() {
    super("appointment.AppointmentStreamResponse", [
      {
        no: 1,
        name: "event_type",
        kind: "enum",
        T: () => [
          "appointment.AppointmentStreamResponse.EventType",
          AppointmentStreamResponse_EventType,
        ],
      },
      { no: 2, name: "appointment", kind: "message", T: () => Appointment },
    ]);
  }
  create(
    value?: PartialMessage<AppointmentStreamResponse>
  ): AppointmentStreamResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.eventType = 0;
    if (value !== undefined)
      reflectionMergePartial<AppointmentStreamResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppointmentStreamResponse
  ): AppointmentStreamResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* appointment.AppointmentStreamResponse.EventType event_type */ 1:
          message.eventType = reader.int32();
          break;
        case /* appointment.Appointment appointment */ 2:
          message.appointment = Appointment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.appointment
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppointmentStreamResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* appointment.AppointmentStreamResponse.EventType event_type = 1; */
    if (message.eventType !== 0)
      writer.tag(1, WireType.Varint).int32(message.eventType);
    /* appointment.Appointment appointment = 2; */
    if (message.appointment)
      Appointment.internalBinaryWrite(
        message.appointment,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message appointment.AppointmentStreamResponse
 */
export const AppointmentStreamResponse = new AppointmentStreamResponse$Type();
/**
 * @generated ServiceType for protobuf service appointment.AppointmentService
 */
export const AppointmentService = new ServiceType(
  "appointment.AppointmentService",
  [
    {
      name: "CreateAppointment",
      options: {},
      I: CreateAppointmentRequest,
      O: Appointment,
    },
    {
      name: "GetAppointment",
      options: {},
      I: GetAppointmentRequest,
      O: Appointment,
    },
    {
      name: "DeleteAppointment",
      options: {},
      I: DeleteAppointmentRequest,
      O: Empty,
    },
    {
      name: "ListAppointments",
      options: {},
      I: ListAppointmentsRequest,
      O: ListAppointmentsResponse,
    },
    {
      name: "StreamAppointments",
      serverStreaming: true,
      options: {},
      I: Empty,
      O: AppointmentStreamResponse,
    },
  ]
);
